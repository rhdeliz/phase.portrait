#' @name iterate_plotting
#' @title Generate Multiple Plots with Fixed or Dynamic Axes
#' This function iterates over a dataset and generates multiple plots using a specified plotting function. It supports fixed or dynamic axis limits based on the overall dataset or additional arguments provided. Each subset of data is passed to the plotting function along with optional parameters.
#' @param df A data frame containing the dataset with `x`, `y`, `x_label`, and `y_label` columns.
#' @param fx A function to generate individual plots. It should accept arguments `df_split`, `input`, `save`,
#'   and optionally `min_x`, `max_x`, `min_y`, `max_y`.
#' @param input A character string specifying the input type, either "standard" or "fraction". Default is "standard".
#' @param fixed_axes Logical. If TRUE, uses global axis limits for all plots. If FALSE, each plot can have dynamic axis limits. Default is TRUE.
#' @param save Logical. If TRUE, saves each plot generated by the `fx` function. Default is FALSE.
#' @param n_cores Integer. Specifies the number of cores to use for parallel processing. Default is NULL (automatically detects available cores).
#' @param ... Additional arguments passed to `fx`, allowing custom axis limits (`min_x`, `max_x`, `min_y`, `max_y`).
#'
#' @return A list of plots generated by the `fx` function, each created based on a subset of `df`.
#' @examples
#' # Example usage:
#' # plots <- iterate_plotting(df, fx = plot_phase_portrait, input = "standard", fixed_axes = TRUE)
#' @export
#' @import data.table
#' @import dplyr
#' @import parallel
iterate_plotting <- function(df, fx, input = "standard", fixed_axes = TRUE, save = FALSE, n_cores = NULL, ...) {
  # Capture additional arguments passed to the function
  extra_args <- list(...)

  # Override 'input' with df$input[1] if the 'input' column exists in df
  if ("input" %in% names(df)) {
    input <- df$input[1]
  }

  # Set the number of cores for parallel processing, defaulting to available cores minus 2
  if (is.null(n_cores)) {
    n_cores <- max(1, detectCores() - 2)
  }

  # Windows-specific setup for parallel processing using a cluster
  if (.Platform$OS.type == "windows") {
    cl <- tryCatch({
      suppressWarnings(makeCluster(n_cores))
    }, warning = function(w) {
      invokeRestart("muffleWarning")
    }, error = function(e) {
      stop("Error in creating cluster: ", e$message)
    })
    on.exit(stopCluster(cl)) # Ensure the cluster stops after execution
    clusterEvalQ(cl, {
      library(dplyr)
      library(data.table)
    })
  }

  # Calculate global axis limits (min and max values for x and y) if fixed_axes is TRUE
  limits_df <- df[, .(min_x = min(x[is.finite(x)], na.rm = TRUE),
                      max_x = max(x[is.finite(x)], na.rm = TRUE),
                      min_y = min(y[is.finite(y)], na.rm = TRUE),
                      max_y = max(y[is.finite(y)], na.rm = TRUE))]

  # Split the data into subsets based on unique values in x_label and y_label
  split_pp <- df %>% group_split(x_label, y_label)

  # Internal function to apply the plotting function (fx) to each subset of data
  plot_fx <- function(df_split, extra_args) {
    # Base arguments for fx
    args <- list(
      df = df_split,  # Dataset subset for plotting
      input = input,  # Input type for plotting (standard or fraction)
      save = save     # Whether to save the plot
    )

    # Exclude axis limits from extra_args if fixed_axes is TRUE
    extra_args <- extra_args[!names(extra_args) %in% c("min_x", "max_x", "min_y", "max_y")]

    # Conditionally add axis limits if fixed_axes is TRUE
    if (fixed_axes) {
      args$min_x <- limits_df$min_x
      args$max_x <- limits_df$max_x
      args$min_y <- limits_df$min_y
      args$max_y <- limits_df$max_y
    }

    # Remove NULL values from args
    args <- args[!sapply(args, is.null)]

    # Include any additional arguments not already in args
    extra_args_to_add <- extra_args[setdiff(names(extra_args), names(args))]
    args <- c(args, extra_args_to_add)

    # Call the plotting function with the combined arguments
    do.call(fx, args)
  }

  # Apply plotting function to each subset in parallel or sequentially
  if (.Platform$OS.type == "windows") {
    # Export necessary objects to the cluster for Windows parallel processing
    clusterExport(cl, varlist = c("plot_fx", "fx", "input", "save", "fixed_axes", "limits_df", "extra_args"), envir = environment())

    # Generate plots in parallel using parLapply
    plots <- parLapply(cl, split_pp, plot_fx, extra_args)
  } else if (n_cores == 1) {
    # Sequential processing for single-core execution
    plots <- lapply(split_pp, plot_fx, extra_args)
  } else {
    # Parallel processing for Unix-based systems
    plots <- mclapply(split_pp, plot_fx, extra_args, mc.cores = n_cores)
  }

  return(plots) # Return the list of generated plots
}
