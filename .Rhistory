usethis::use_readme_rmd()
setwd("/Users/rdeliza/phase.portrait")
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
devtools::build_manual()
#' Calculate Rate of Change (Delta) in Values Over Time
#'
#' This function calculates the rate of change (delta) in the `value` column over `pseudotime`.
#' The calculation method can be specified as lead, lag, or lead-lag.
#'
#' @param df A data frame with `value`, `pseudotime`, `sample`, `condition`, and `variable` columns.
#' @param derivative A character string specifying the derivative method to calculate the rate of change.
#'   Options are:
#'   - `"lead"` (default): Uses the next timepoint to calculate the change.
#'   - `"lag"`: Uses the previous timepoint to calculate the change.
#'   - `"lead-lag"`: Calculates the change over two surrounding timepoints, useful for datasets with more than two timepoints.
#' @return A data frame with an added `delta` column representing the rate of change in `value` over `pseudotime`.
#' @examples
#' df <- data.frame(
#'   value = c(1, 2, 3, 4, 5),
#'   pseudotime = c(1, 2, 3, 4, 5),
#'   sample = "sample1",
#'   condition = "condition1",
#'   variable = "variable1"
#' )
#' calculate_derivatives(df, derivative = "lead-lag")
#'
library(dplyr)
library(data.table)
library(parallel)
calculate_derivatives <- function(df, derivative = "lead", save = FALSE) {
# Check for valid derivative method
if (!derivative %in% c("lead", "lag", "lead-lag")) {
stop("Derivative method does not exist. Choose 'lead', 'lag', or 'lead-lag'.")
}
# Arrange and group data by specified columns
df <- df %>%
arrange(pseudotime) %>%
group_by(condition, sample, variable)
# Calculate delta based on the chosen derivative method
if (derivative == "lead") {
df <- df %>% mutate(delta = (lead(value) - value) / (lead(pseudotime) - pseudotime))
} else if (derivative == "lag") {
df <- df %>% mutate(delta = (value - lag(value)) / (pseudotime - lag(pseudotime)))
} else if (derivative == "lead-lag") {
df <- df %>% mutate(delta = (lead(value) - lag(value)) / (lead(pseudotime) - lag(pseudotime)))
}
df <- as.data.table(df)
return(df)
}
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
devtools::build_manual()
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
#' @name iterate_plotting
#' @title Generate Multiple Plots with Fixed or Dynamic Axes
#' This function iterates over a dataset and generates multiple plots using a specified plotting function. It supports fixed or dynamic axis limits based on the overall dataset or additional arguments provided. Each subset of data is passed to the plotting function along with optional parameters.
#' @param df A data frame containing the dataset with `x`, `y`, `x_label`, and `y_label` columns.
#' @param fx A function to generate individual plots. It should accept arguments `df_split`, `input`, `save`,
#'   and optionally `min_x`, `max_x`, `min_y`, `max_y`.
#' @param input A character string specifying the input type, either "standard" or "fraction". Default is "standard".
#' @param fixed_axes Logical. If TRUE, uses global axis limits for all plots. If FALSE, each plot can have dynamic axis limits. Default is TRUE.
#' @param save Logical. If TRUE, saves each plot generated by the `fx` function. Default is FALSE.
#' @param ... Additional arguments passed to `fx`, allowing custom axis limits (`min_x`, `max_x`, `min_y`, `max_y`).
#'
#' @return A list of plots generated by the `fx` function, each created based on a subset of `df`.
#' @examples
#' # Example usage:
#' # plots <- iterate_plotting(df, fx = plot_phase_portrait, input = "standard", fixed_axes = TRUE)
#'
iterate_plotting <- function(df, fx, input = "standard", fixed_axes = TRUE, save = FALSE, ...) {
# Override 'input' with df$input[1] if 'input' column exists in df
if ("input" %in% names(df)) {
input <- df$input[1]
}
# Calculate global axis limits based on entire dataset
limits_df <- df %>%
ungroup() %>%
summarise(
min_x = min(x, na.rm = TRUE),
max_x = max(x, na.rm = TRUE),
min_y = min(y, na.rm = TRUE),
max_y = max(y, na.rm = TRUE)
)
# Extract additional arguments from `...`
extra_args <- list(...)
# Split the data by x_label and y_label
split_pp <- df %>% group_split(x_label, y_label)
# Call the plotting function, passing all additional arguments with ...
plots <- lapply(split_pp, function(df_split) {
args <- list(
df_split,
input = input,
save = save
)
# Conditionally add limits based on fixed_axes and availability in extra_args
if (fixed_axes || !is.null(extra_args$min_x)) args$min_x <- ifelse(!is.null(extra_args$min_x), extra_args$min_x, limits_df$min_x)
if (fixed_axes || !is.null(extra_args$max_x)) args$max_x <- ifelse(!is.null(extra_args$max_x), extra_args$max_x, limits_df$max_x)
if (fixed_axes || !is.null(extra_args$min_y)) args$min_y <- ifelse(!is.null(extra_args$min_y), extra_args$min_y, limits_df$min_y)
if (fixed_axes || !is.null(extra_args$max_y)) args$max_y <- ifelse(!is.null(extra_args$max_y), extra_args$max_y, limits_df$max_y)
do.call(fx, args)
})
return(plots)
}
devtools::document()
devtools::document()
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
Normalize Values
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
devtools::build_manual()
usethis::proj_get()
usethis::use_readme_rmd()
usethis::proj_get()
devtools::document()
devtools::build_manual()
